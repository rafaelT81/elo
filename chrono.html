<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Horloge d'Échecs</title>
    <!-- Favicon (ajouté) -->
    <link rel="icon" type="image/x-icon" href="favicon.ico"> 
    <!-- Chargement de Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Configuration de la police Inter et adaptation pour mobile */
        :root {
            font-family: 'Inter', sans-serif;
            height: 100vh;
            overflow: hidden;
        }

        body {
            height: 100%;
            margin: 0;
            /* Flex vertical par défaut (mobile) */
            display: flex;
            flex-direction: column;
            /* En desktop, on passe en mode horizontal */
            @media (min-width: 640px) { /* sm breakpoint */
                flex-direction: row;
            }
        }

        /* Style de base pour l'ensemble de l'affichage de l'horloge */
        .clock-display {
            display: flex; /* Permet d'aligner la partie MM:SS et la partie .MS */
            align-items: flex-end; /* CRITICAL: Alignement en bas (même ligne de base) */
            justify-content: center;
            /* Le texte doit être au-dessus du hint mais laisser passer le clic au parent */
            pointer-events: none; 
            z-index: 12;
            /* IMPORTANT: Permet d'encapsuler le témoin et le temps pour le centrer */
            flex-direction: column; 
            align-items: center;
        }

        /* Conteneur pour le temps seul (MM:SS.CS) */
        .time-wrapper {
            display: flex;
            align-items: flex-end;
        }

        /* Témoin lumineux (Pastille plus haute) */
        .active-indicator {
            width: 2.5rem; /* 40px sur mobile */
            height: 2.5rem; /* 40px sur mobile */
            border-radius: 9999px; /* Cercle */
            
            /* Espace entre le témoin et le temps */
            margin-bottom: 1.5rem; 
            
            transition: opacity 0.3s, background-color 0.3s;
            opacity: 0; /* Caché par défaut */
            @media (min-width: 640px) {
                width: 2rem; /* 32px sur desktop */
                height: 2rem; /* 32px sur desktop */
                margin-bottom: 0.75rem; /* Espace desktop */
            }
        }

        /* Styles spécifiques pour le témoin ACTIF du Joueur 1 (fond sombre -> Pastille Blanche) */
        .active-indicator.active-p1-white {
            background-color: white; 
            opacity: 1;
        }

        /* Styles spécifiques pour le témoin ACTIF du Joueur 2 (fond clair -> Pastille Foncée / Couleur du Texte) */
        .active-indicator.active-p2-dark {
            background-color: #1e293b; /* Slate-800, couleur du texte de P2 */
            opacity: 1;
        }


        /*
         * TAILLE DES POLICES (AJUSTEMENT CRITIQUE)
         */
        /* Style pour les grands nombres (MM:SS) */
        .main-time {
            /* Mobile (par défaut, très grand) */
            font-size: 18vw; 
            font-weight: 900;
            line-height: 1;
            text-shadow: 0 0 5px rgba(0,0,0,0.1);
            transition: color 0.1s;
             /* Desktop (plus petit) - AUCUN CHANGEMENT */
            @media (min-width: 640px) {
                font-size: 8vw;
            }
        }
        
        /* Style pour les centièmes de seconde (.CS) */
        .hundredths {
            /* Mobile (par défaut, grand) */
            font-size: 10vw; 
            font-weight: 900; 
            line-height: 1;
            /* Ajout pour l'alignement visuel de la ligne de base */
            transform: translateY(-6%); 
             /* Desktop (plus petit) - AUCUN CHANGEMENT */
            @media (min-width: 640px) {
                font-size: 4vw;
            }
        }

        /* STYLES pour le message WIN */
        .winner-overlay {
            /* Adapté pour suivre les centièmes de seconde (ajusté pour rester lisible) */
            font-size: 10vw; /* Harmonisé avec .hundredths */
            font-weight: 900; 
            line-height: 1;
            text-shadow: 0 0 5px rgba(0,0,0,0.2); 
            z-index: 15;
            pointer-events: none;
            text-transform: uppercase;
            letter-spacing: 1px;
            position: absolute; 
            top: 15%; 
            left: 50%;
            transform: translateX(-50%);
            
            @media (min-width: 640px) {
                font-size: 4vw;
            }
        }

        /* Les zones des joueurs doivent occuper l'espace disponible */
        .player-zone {
            flex-grow: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.3s, transform 0.1s, box-shadow 0.2s;
            cursor: pointer;
            user-select: none;
            touch-action: manipulation;
            width: 100%;
            height: 50%; /* 50% de la hauteur en mode mobile (colonne) */
            position: relative; 
            z-index: 10; 

            @media (min-width: 640px) {
                width: 50%; /* 50% de la largeur en mode desktop (ligne) */
                height: 100%; /* 100% de la hauteur */
            }
        }

        /* Styles spécifiques pour le joueur 1 */
        #player1-zone {
            background-color: #1e293b; /* Slate-800 */
            color: white;
            /* Rotation par défaut (mobile: chronomètre "à l'envers" pour le joueur du haut) */
            transform: rotate(180deg); 
             /* Annule la rotation en mode desktop pour affichage de gauche à droite (DROIT) */
            @media (min-width: 640px) {
                transform: rotate(0deg); 
            }
        }

        /* Styles spécifiques pour le joueur 2 */
        #player2-zone {
            background-color: #f1f5f9; /* Slate-100 */
            color: #1e293b; /* Slate-800 */
            /* Pas de rotation sur mobile (DROIT) */
            /* Annule la rotation en mode desktop (DROIT) */
            @media (min-width: 640px) {
                transform: rotate(0deg); 
            }
        }

        /* Effet de pression sur la zone active */
        .player-zone:active {
            filter: brightness(0.9);
        }

        /* Style pour l'input de temps (grand sur mobile) */
        #minutes-input, #seconds-input {
            appearance: none;
            -moz-appearance: textfield;
        }
        #minutes-input::-webkit-inner-spin-button, 
        #minutes-input::-webkit-outer-spin-button,
        #seconds-input::-webkit-inner-spin-button, 
        #seconds-input::-webkit-outer-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
    </style>
</head>
<body class="bg-gray-50">

    <!-- Zone du Joueur 1 (Gauche en Desktop, Haut en Mobile) -->
    <div id="player1-zone" class="player-zone" onclick="switchPlayer(1)">
        <!-- Message WIN -->
        <div id="winner-overlay-1" class="winner-overlay hidden">GAGNANT</div>
        
        <!-- Conteneur principal du temps (avec le témoin) -->
        <div id="time1" class="clock-display">
            <!-- Témoin Visuel -->
            <div id="indicator1" class="active-indicator"></div>
            <!-- L'affichage du temps sera généré par innerHTML -->
            <span class="time-wrapper">
                <span class="main-time">05:00</span>
                <span class="hundredths">.00</span>
            </span>
        </div>
    </div>

    <!-- Contrôles Centraux -->
    <!-- J'ai retiré 'flex items-center justify-center' pour pouvoir positionner le main-button en absolu sur la ligne de séparation -->
    <div id="controls" class="absolute inset-0 pointer-events-none">
        
        <!-- Bouton Démarrer/Pause/Gagnant -->
        <button id="main-button"
                onclick="event.stopPropagation(); startStop()"
                class="pointer-events-auto bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-6 rounded-full shadow-lg transition duration-200 text-xl md:text-xl z-20 hidden
                       absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2">
            Pause
        </button>

        <!-- Bouton de Classement Elo -->
        <button id="elo-button"
                onclick="window.location.href='classement-elo.html'"
                class="pointer-events-auto absolute top-4 right-4 bg-gray-300 hover:bg-gray-400 text-gray-800 p-4 rounded-full shadow-lg transition duration-200 z-20 hidden">
            <!-- Icône de flèche droite SVG -->
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-6 h-6">
                <path d="M5 12h14M12 5l7 7-7 7"/>
            </svg>
        </button>

        <!-- Bouton de Réglages (Engrenage) -->
        <button id="settings-button"
                onclick="event.stopPropagation(); toggleSettings(true)"
                class="pointer-events-auto absolute bottom-4 left-4 bg-gray-300 hover:bg-gray-400 text-white p-4 rounded-full shadow-lg transition duration-200 z-20 hidden">
            <!-- Icône d'engrenage SVG (Couleur du texte des boutons, BLANC) -->
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-6 h-6 text-gray-800">
                <circle cx="12" cy="12" r="3" />
                <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09a1.65 1.65 0 0 0 1.51-1 1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z" />
            </svg>
        </button>

        <!-- Bouton de Réinitialisation -->
        <button id="reset-button"
                onclick="event.stopPropagation(); resetGame()"
                class="pointer-events-auto absolute bottom-4 right-4 bg-gray-300 hover:bg-gray-400 text-gray-800 text-base font-semibold py-3 px-4 rounded-lg shadow transition duration-200 z-20 hidden">
            Réinitialiser
        </button>
    </div>

    <!-- Zone du Joueur 2 (Droite en Desktop, Bas en Mobile) -->
    <div id="player2-zone" class="player-zone" onclick="switchPlayer(2)">
        <!-- Message WIN -->
        <div id="winner-overlay-2" class="winner-overlay hidden">GAGNANT</div>
        
        <!-- Conteneur principal du temps (avec le témoin) -->
        <div id="time2" class="clock-display">
            <!-- Témoin Visuel -->
            <div id="indicator2" class="active-indicator"></div>
            <!-- L'affichage du temps sera généré par innerHTML -->
            <span class="time-wrapper">
                <span class="main-time">05:00</span>
                <span class="hundredths">.00</span>
            </span>
        </div>
    </div>

    <!-- MODALE DE RÉGLAGES -->
    <div id="settings-modal" class="fixed inset-0 bg-black bg-opacity-70 z-30 hidden flex items-center justify-center p-4" onclick="toggleSettings(false, event)">
        <div class="bg-white rounded-xl shadow-2xl w-full max-w-sm p-6 space-y-6 md:space-y-8" onclick="event.stopPropagation()">
            <h2 class="text-2xl font-bold text-gray-800 border-b pb-2">Réglages de l'Horloge</h2>
            
            <!-- Choix du Temps Initial (Mis à jour pour Minutes:Secondes) -->
            <div class="space-y-2">
                <label for="minutes-input" class="text-lg font-semibold text-gray-700 block text-center">Temps initial (Minutes:Secondes)</label>
                <div class="flex items-center space-x-2">
                    <!-- Input Minutes -->
                    <input type="number" id="minutes-input" min="0" max="180" value="5"
                           class="w-1/2 text-center text-4xl font-extrabold p-3 border-2 border-indigo-400 rounded-lg focus:ring-indigo-500 focus:border-indigo-500 transition">
                    <span class="text-4xl font-extrabold text-gray-500">:</span>
                    <!-- Input Secondes -->
                    <input type="number" id="seconds-input" min="0" max="59" value="0"
                           class="w-1/2 text-center text-4xl font-extrabold p-3 border-2 border-indigo-400 rounded-lg focus:ring-indigo-500 focus:border-indigo-500 transition">
                </div>
            </div>

            <!-- Choix de l'Incrément -->
            <div class="space-y-3">
                <label class="text-lg font-semibold text-gray-700 block">Incrément par coup (Secondes)</label>
                
                <div class="flex flex-wrap gap-2 md:gap-4 justify-center">
                    <!-- Bouton +0 -->
                    <button data-increment="0" class="inc-btn bg-gray-200 hover:bg-gray-300 text-gray-800 font-medium py-2 px-4 rounded-full transition duration-150">
                        +0s
                    </button>
                    <!-- Bouton +2 -->
                    <button data-increment="2" class="inc-btn bg-gray-200 hover:bg-gray-300 text-gray-800 font-medium py-2 px-4 rounded-full transition duration-150">
                        +2s
                    </button>
                    <!-- Bouton +5 -->
                    <button data-increment="5" class="inc-btn bg-gray-200 hover:bg-gray-300 text-gray-800 font-medium py-2 px-4 rounded-full transition duration-150">
                        +5s
                    </button>
                    <!-- Input Personnalisé -->
                    <input type="number" id="custom-increment-input" min="0" max="60" placeholder="+ Perso"
                           class="w-24 text-center font-medium p-2 border border-gray-300 rounded-full focus:ring-indigo-500 focus:border-indigo-500 transition text-gray-800">
                </div>
                
                <p id="current-increment-display" class="text-center text-sm text-indigo-600 font-medium pt-2">
                    Incrément sélectionné : +0 secondes
                </p>
            </div>
            
            <!-- Bouton Appliquer et Fermer -->
            <button onclick="applySettings()"
                    class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-3 rounded-lg shadow-md transition duration-200 text-lg">
                Appliquer et Réinitialiser
            </button>
        </div>
    </div>

    <script>
        // --- Configuration initiale ---
        // Temps initial est maintenant stocké en secondes
        let initialTimeTotalSeconds = 300; // 5 minutes par défaut (5 * 60)
        let incrementSeconds = 0; // Incrément par défaut en secondes
        const timeLimitMs = 10; // Intervalle de 10ms pour afficher les centièmes

        // --- Variables d'état du jeu ---
        let time1 = initialTimeTotalSeconds;
        let time2 = initialTimeTotalSeconds;
        let isRunning = false; // Le jeu est-il en session (démarré ou en pause) ?
        let isTicking = false; // Le chronomètre est-il en cours de décompte ?
        let currentPlayer = 0; // 0: Prêt/Arrêté, 1: Joueur 1 (Haut/Gauche), 2: Joueur 2 (Bas/Droite)
        let winnerPlayer = 0; // 0: Pas de gagnant, 1: P1 gagne, 2: P2 gagne
        let timerInterval;

        // --- Références DOM ---
        const time1El = document.getElementById('time1');
        const time2El = document.getElementById('time2');
        const player1ZoneEl = document.getElementById('player1-zone');
        const player2ZoneEl = document.getElementById('player2-zone');
        const mainButtonEl = document.getElementById('main-button');
        const resetButtonEl = document.getElementById('reset-button');
        const settingsModalEl = document.getElementById('settings-modal');
        const minutesInputEl = document.getElementById('minutes-input');
        const secondsInputEl = document.getElementById('seconds-input');
        const incrementButtons = document.querySelectorAll('.inc-btn');
        const customIncrementInput = document.getElementById('custom-increment-input');
        const currentIncrementDisplay = document.getElementById('current-increment-display');
        const winnerOverlay1El = document.getElementById('winner-overlay-1');
        const winnerOverlay2El = document.getElementById('winner-overlay-2');
        
        // --- Fonctions Utilitaires ---

        // Formate les secondes en MM:SS et centièmes de seconde (.CS)
        function formatTime(totalSeconds) {
            if (totalSeconds < 0) totalSeconds = 0;

            // Utilise les millisecondes pour une meilleure précision d'affichage
            const totalMs = Math.max(0, Math.round(totalSeconds * 1000));
            
            const minutes = Math.floor(totalMs / 60000);
            const seconds = Math.floor((totalMs % 60000) / 1000);
            
            // Calcule les centièmes (les deux premiers chiffres de la partie décimale)
            const hundredths = Math.floor((totalMs % 1000) / 10); 

            const mmss = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
            // Affiche les centièmes sur deux chiffres
            const cs = `${String(hundredths).padStart(2, '0')}`; 

            return { mmss, cs };
        }

        // --- Logique de l'Horloge ---

        // Met à jour l'affichage de l'horloge pour un joueur
        function updateDisplay(player) {
            const time = player === 1 ? time1 : time2;
            const element = player === 1 ? time1El : time2El;
            const zone = player === 1 ? player1ZoneEl : player2ZoneEl;
            const winnerOverlayEl = player === 1 ? winnerOverlay1El : winnerOverlay2El;

            // Nouvelle logique de formatage pour MM:SS et .CS
            const { mmss, cs } = formatTime(time);

            // Mise à jour de l'affichage avec le formatage HTML (on garde la structure du témoin)
            const timeHTML = `
                <div id="indicator${player}" class="active-indicator"></div>
                <span class="time-wrapper">
                    <span class="main-time">${mmss}</span>
                    <span class="hundredths">.${cs}</span>
                </span>
            `;
            element.innerHTML = timeHTML; 


            // Récupère la couleur de base pour gérer le changement de couleur d'alerte
            const baseColor1 = '#1e293b'; // Slate-800 (Fond P1 / Texte P2)
            const baseColor2 = '#f1f5f9'; // Slate-100 (Fond P2)
            const alertColor = '#ef4444'; // Rouge-500

            // Gère l'état visuel (ombre, curseur, couleur du fond)
            if (currentPlayer === player && isTicking) {
                zone.classList.add('shadow-2xl'); 
                zone.style.cursor = 'pointer';
            } else {
                zone.classList.remove('shadow-2xl');
                zone.style.cursor = 'default';
            }

            // Gère la couleur d'alerte de temps bas
            const isLowTime = currentPlayer === player && isTicking && time < 10 && time > 0;
            
            zone.style.backgroundColor = isLowTime 
                ? alertColor
                : (player === 1 ? baseColor1 : baseColor2);
            
            // Gère la couleur du texte (spécifique pour P2)
            if (player === 2) {
                const textColor = isLowTime ? 'white' : baseColor1;
                if (zone) zone.style.color = textColor;
                winnerOverlay2El.style.color = baseColor1; 
            } else {
                 if (zone) zone.style.color = 'white';
                 winnerOverlay1El.style.color = 'white'; 
            }

            // Gère l'affichage du message WIN
            if (winnerPlayer === player) {
                winnerOverlayEl.classList.remove('hidden');
            } else {
                winnerOverlayEl.classList.add('hidden');
            }

             // Mise à jour de l'indicateur visuel (doit être fait après l'update de innerHTML)
             const currentIndicatorEl = document.getElementById(`indicator${player}`);
             if (currentIndicatorEl) {
                 // Supprime les anciennes classes d'indicateur
                 currentIndicatorEl.classList.remove('active-p1-white', 'active-p2-dark');

                 if (currentPlayer === player && isTicking) {
                     // Ajoute la classe spécifique selon le joueur
                     // P1 (fond sombre) -> Pastille Blanche
                     // P2 (fond clair) -> Pastille Foncée (couleur du texte)
                     currentIndicatorEl.classList.add(player === 1 ? 'active-p1-white' : 'active-p2-dark');
                 }
             }

        }

        // Fonction principale de décompte
        function tick() {
            if (!isTicking) return;

            // Décrément en secondes (10ms / 1000 = 0.01s)
            const timeDecrement = timeLimitMs / 1000;

            if (currentPlayer === 1) {
                time1 -= timeDecrement;
                if (time1 <= 0) {
                    time1 = 0;
                    gameOver(1);
                }
            } else if (currentPlayer === 2) {
                time2 -= timeDecrement;
                if (time2 <= 0) {
                    time2 = 0;
                    gameOver(2);
                }
            }

            updateDisplay(1);
            updateDisplay(2);
        }

        // Change de joueur et applique l'incrément
        function switchPlayer(clickedPlayer) {
            console.log(`[Switch] Clic sur P${clickedPlayer}. État: P${currentPlayer}, Ticking: ${isTicking}, Running: ${isRunning}`);
            
            const isGameOver = time1 <= 0 || time2 <= 0;
            if (isGameOver) return;

            // LOGIQUE DE DÉMARRAGE SIMPLIFIÉE :
            if (!isRunning) {
                isRunning = true; 
                isTicking = true; 
                
                currentPlayer = clickedPlayer === 1 ? 2 : 1; 

                timerInterval = setInterval(tick, timeLimitMs);
                console.log(`[Switch] Démarrage initial par P${clickedPlayer}. Horloge P${currentPlayer} démarrée.`);
            }
            // Logique de COUP NORMAL : Horloge en cours de décompte
            else if (isTicking) {
                if (clickedPlayer === currentPlayer) {
                    
                    if (currentPlayer === 1) {
                        time1 += incrementSeconds;
                        currentPlayer = 2; 
                        console.log(`[Switch] P1 joue. Nouveau Joueur: P${currentPlayer}.`);
                    } else { // currentPlayer === 2
                        time2 += incrementSeconds;
                        currentPlayer = 1; 
                        console.log(`[Switch] P2 joue. Nouveau Joueur: P${currentPlayer}.`);
                    }
                } else {
                    console.log(`[Switch] Rejet: Clic sur P${clickedPlayer}, mais P${currentPlayer} est actif.`);
                    return;
                }
            }
            // Si en pause, on ignore le clic sur la zone
            else if (isRunning && !isTicking) {
                 console.log("[Switch] Rejet: Horloge en pause, veuillez utiliser le bouton 'Reprendre'.");
                 return;
            }

            updateVisuals();
        }
        
        // Fonction qui encapsule la logique de passage de joueur (pour le clavier)
        function handleSpacebarPress() {
            if (isTicking) {
                switchPlayer(currentPlayer);
            } 
            else if (isRunning && !isTicking && time1 > 0 && time2 > 0) {
                 startStop();
            }
        }

        // Démarre, met en pause ou initialise la partie (Maintenant seulement Pause/Reprendre)
        function startStop() {
            if (!isRunning || time1 <= 0 || time2 <= 0) return; 

            // Case 1: L'horloge compte activement -> PAUSE
            if (isTicking) {
                clearInterval(timerInterval);
                isTicking = false;
                console.log(`[StartStop] Pause. Joueur en attente: ${currentPlayer}`);
            } 
            // Case 2: Le jeu est PAUSE -> REPRENDRE
            else {
                isTicking = true;
                timerInterval = setInterval(tick, timeLimitMs);
                console.log(`[StartStop] Reprise de la partie. Joueur actif: ${currentPlayer}`);
            }

            updateVisuals();
        }

        // Gère la fin de partie
        function gameOver(loser) {
            isRunning = false;
            isTicking = false;
            clearInterval(timerInterval);
            currentPlayer = 0;
            winnerPlayer = loser === 1 ? 2 : 1; 

            // Mise à jour du bouton central
            mainButtonEl.textContent = `Fin de Partie`; 
            mainButtonEl.classList.remove('bg-indigo-600', 'hover:bg-indigo-700', 'bg-green-600', 'hover:bg-green-700', 'bg-gray-600', 'hover:bg-gray-700');
            mainButtonEl.classList.add('bg-gray-600', 'hover:bg-gray-700'); 
            
            // Met à jour l'affichage et l'indicateur pour masquer l'indicateur
            updateDisplay(1);
            updateDisplay(2);
            updateVisuals();
        }

        // Réinitialise l'horloge
        function resetGame() {
            clearInterval(timerInterval);
            time1 = initialTimeTotalSeconds;
            time2 = initialTimeTotalSeconds;
            isRunning = false; 
            isTicking = false; 
            currentPlayer = 0;
            winnerPlayer = 0; 
            console.log("[Reset] Jeu réinitialisé.");

            // Rétablit l'interface
            mainButtonEl.classList.remove('bg-gray-600', 'hover:bg-gray-700', 'bg-green-600');
            mainButtonEl.classList.add('bg-indigo-600');
            
            updateVisuals();
        }

        // Met à jour tous les éléments visuels
        function updateVisuals() {
            updateDisplay(1);
            updateDisplay(2);
            
            // État 1: Prêt à démarrer (Pas en cours, temps > 0)
            const isReadyForFirstMove = !isRunning && time1 > 0 && time2 > 0; 
            // État 2: En Pause (En cours, non décompte, temps > 0)
            const isPaused = isRunning && !isTicking && time1 > 0 && time2 > 0;
            // État 3: Game Over
            const isGameOver = time1 <= 0 || time2 <= 0;

            // Contrôle de la visibilité du bouton central : Visible après le premier coup ou fin de partie
            if (isReadyForFirstMove) {
                mainButtonEl.classList.add('hidden'); // Caché avant le premier coup
            } else if (isRunning || isGameOver) {
                mainButtonEl.classList.remove('hidden'); 
            }
            
            // Contrôle du texte et des couleurs du bouton central
            if (isGameOver) {
                // Le texte et la couleur grise sont gérés dans gameOver()
            } else if (isTicking) {
                mainButtonEl.textContent = 'Pause';
                // Bouton Pause (Gris)
                mainButtonEl.classList.remove('bg-indigo-600', 'hover:bg-indigo-700', 'bg-green-600', 'hover:bg-green-700');
                mainButtonEl.classList.add('bg-gray-600', 'hover:bg-gray-700');
            } else if (isPaused) {
                mainButtonEl.textContent = 'Reprendre';
                // Bouton Reprendre (Indigo)
                mainButtonEl.classList.remove('bg-gray-600', 'hover:bg-gray-700', 'bg-green-600', 'hover:bg-green-700');
                mainButtonEl.classList.add('bg-indigo-600', 'hover:bg-indigo-700');
            }

            // Contrôle de la visibilité des boutons de contrôle (Réglages et ELO)
            const isControlVisible = !isTicking;
            document.getElementById('settings-button').classList.toggle('hidden', !isControlVisible);
            resetButtonEl.classList.toggle('hidden', !isControlVisible);
            document.getElementById('elo-button').classList.toggle('hidden', !isControlVisible);

        }

        // --- Logique des Réglages (Mode Édition) ---

        // Ouvre ou ferme la modale de réglages
        function toggleSettings(show, event) {
            if (isRunning) return; // Ne pas ouvrir si le jeu est en cours
            
            if (show) {
                const minutes = Math.floor(initialTimeTotalSeconds / 60);
                const seconds = Math.floor(initialTimeTotalSeconds % 60);

                minutesInputEl.value = minutes;
                secondsInputEl.value = seconds;
                
                customIncrementInput.value = incrementSeconds;
                updateIncrementSelection(incrementSeconds);
                settingsModalEl.classList.remove('hidden');
            } else if (!event || event.target === settingsModalEl) {
                settingsModalEl.classList.add('hidden');
            }
        }

        // Met à jour l'état visuel des boutons d'incrément
        function updateIncrementSelection(selectedIncrement) {
            incrementButtons.forEach(btn => {
                const inc = parseInt(btn.dataset.increment);
                if (inc === selectedIncrement) {
                    btn.classList.add('bg-indigo-600', 'text-white');
                    btn.classList.remove('bg-gray-200', 'text-gray-800');
                } else {
                    btn.classList.remove('bg-indigo-600', 'text-white');
                    btn.classList.add('bg-gray-200', 'text-gray-800');
                }
            });

            customIncrementInput.classList.remove('bg-indigo-600', 'text-white', 'font-bold');
            if (![0, 2, 5].includes(selectedIncrement)) {
                customIncrementInput.classList.add('bg-indigo-600', 'text-white', 'font-bold');
            }

            currentIncrementDisplay.textContent = `Incrément sélectionné : +${selectedIncrement} secondes`;
        }

        // Gestionnaire de clic pour les boutons d'incrément prédéfinis
        incrementButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                const inc = parseInt(btn.dataset.increment);
                incrementSeconds = inc; 
                customIncrementInput.value = ''; 
                updateIncrementSelection(inc);
            });
        });

        // Gestionnaire d'input pour l'incrément personnalisé
        customIncrementInput.addEventListener('input', () => {
            let inc = parseInt(customIncrementInput.value);
            if (isNaN(inc) || inc < 0) inc = 0;
            if (inc > 60) inc = 60; 
            customIncrementInput.value = inc;

            incrementSeconds = inc;
            updateIncrementSelection(inc);
        });

        // Applique les réglages et réinitialise le jeu
        function applySettings() {
            let newMinutes = parseInt(minutesInputEl.value) || 0;
            let newSeconds = parseInt(secondsInputEl.value) || 0;
            let newIncrementSeconds = parseInt(incrementSeconds);

            if (isNaN(newMinutes) || newMinutes < 0) newMinutes = 0;
            if (newMinutes > 180) newMinutes = 180;
            if (isNaN(newSeconds) || newSeconds < 0) newSeconds = 0;
            if (newSeconds > 59) newSeconds = 59;
            
            const newTotalSeconds = (newMinutes * 60) + newSeconds;
            
            if (newTotalSeconds === 0) {
                 initialTimeTotalSeconds = 60; 
            } else {
                 initialTimeTotalSeconds = newTotalSeconds;
            }

            if (isNaN(newIncrementSeconds) || newIncrementSeconds < 0) newIncrementSeconds = 0;

            incrementSeconds = newIncrementSeconds;
            
            if (newTotalSeconds === 0) {
                 minutesInputEl.value = 1;
                 secondsInputEl.value = 0;
            }

            console.log(`[Settings] Temps initial: ${Math.floor(initialTimeTotalSeconds / 60)}:${String(initialTimeTotalSeconds % 60).padStart(2, '0')} (Incrément: ${incrementSeconds} s)`);


            toggleSettings(false); 
            resetGame(); 
        }
        
        // --- Gestionnaire d'Événements Clavier ---
        document.addEventListener('keydown', (event) => {
            if (event.key === ' ' || event.keyCode === 32) {
                event.preventDefault(); 
                
                if (settingsModalEl && !settingsModalEl.classList.contains('hidden')) {
                    return;
                }
                
                handleSpacebarPress();
            }
        });


        // Initialisation au chargement
        window.onload = () => {
            // Initialise l'affichage avec les valeurs par défaut
            resetGame(); 
        }
    </script>
</body>
</html>
