<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Horloge d'Échecs</title>
    <!-- Favicon -->
    <link rel="icon" type="image/x-icon" href="favicon.ico"> 
    <!-- Chargement de Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Configuration de la police Inter et adaptation pour mobile */
        :root {
            font-family: 'Inter', sans-serif;
            height: 100vh;
            overflow: hidden;
        }

        body {
            height: 100%;
            margin: 0;
            /* Flex vertical par défaut (mobile) */
            display: flex;
            flex-direction: column;
            /* En desktop, on passe en mode horizontal */
            @media (min-width: 640px) { /* sm breakpoint */
                flex-direction: row;
            }
        }

        /* Style de base pour l'ensemble de l'affichage de l'horloge */
        .clock-display {
            display: flex; 
            align-items: flex-end; 
            justify-content: center;
            pointer-events: none; 
            z-index: 12;
            flex-direction: column; 
            align-items: center;
        }

        /* Conteneur pour le temps seul (MM:SS.CS) */
        .time-wrapper {
            display: flex;
            align-items: flex-end;
        }

        /* Témoin lumineux */
        .active-indicator {
            width: 2.5rem; 
            height: 2.5rem; 
            border-radius: 9999px; 
            margin-bottom: 1.5rem; 
            transition: opacity 0.3s, background-color 0.3s;
            opacity: 0; 
            @media (min-width: 640px) {
                width: 2rem; 
                height: 2rem; 
                margin-bottom: 0.75rem; 
            }
        }

        /* Styles spécifiques pour le témoin ACTIF du Joueur 1 (fond sombre -> Pastille Blanche) */
        .active-indicator.active-p1-white {
            background-color: white; 
            opacity: 1;
        }

        /* Styles spécifiques pour le témoin ACTIF du Joueur 2 (fond clair -> Pastille Foncée / Couleur du Texte) */
        .active-indicator.active-p2-dark {
            background-color: #1e293b; /* Slate-800, couleur du texte de P2 */
            opacity: 1;
        }


        /* TAILLE DES POLICES (AJUSTEMENT CRITIQUE) */
        .main-time {
            font-size: 18vw; 
            font-weight: 900;
            line-height: 1;
            text-shadow: 0 0 5px rgba(0,0,0,0.1);
            transition: color 0.1s;
            @media (min-width: 640px) {
                font-size: 8vw;
            }
        }
        
        .hundredths {
            font-size: 10vw; 
            font-weight: 900; 
            line-height: 1;
            transform: translateY(-6%); 
            @media (min-width: 640px) {
                font-size: 4vw;
            }
        }

        /* STYLES pour le message WIN */
        .winner-overlay {
            font-size: 10vw; 
            font-weight: 900; 
            line-height: 1;
            text-shadow: 0 0 5px rgba(0,0,0,0.2); 
            z-index: 15;
            pointer-events: none;
            text-transform: uppercase;
            letter-spacing: 1px;
            position: absolute; 
            top: 15%; 
            left: 50%;
            transform: translateX(-50%);
            
            @media (min-width: 640px) {
                font-size: 4vw;
            }
        }

        /* Les zones des joueurs doivent occuper l'espace disponible */
        .player-zone {
            flex-grow: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.3s, transform 0.1s, box-shadow 0.2s;
            cursor: pointer;
            user-select: none;
            touch-action: manipulation;
            width: 100%;
            height: 50%; 
            position: relative; 
            z-index: 10; 

            @media (min-width: 640px) {
                width: 50%; 
                height: 100%; 
            }
        }

        /* Styles spécifiques pour le joueur 1 */
        #player1-zone {
            background-color: #1e293b; /* Slate-800 */
            color: white;
            transform: rotate(180deg); 
            @media (min-width: 640px) {
                transform: rotate(0deg); 
            }
        }

        /* Styles spécifiques pour le joueur 2 */
        #player2-zone {
            background-color: #f1f5f9; /* Slate-100 */
            color: #1e293b; /* Slate-800 */
            @media (min-width: 640px) {
                transform: rotate(0deg); 
            }
        }

        /* Effet de pression sur la zone active */
        .player-zone:active {
            filter: brightness(0.9);
        }

        /* Style pour l'input de temps (grand sur mobile) */
        #minutes-input, #seconds-input {
            appearance: none;
            -moz-appearance: textfield;
        }
        #minutes-input::-webkit-inner-spin-button, 
        #minutes-input::-webkit-outer-spin-button,
        #seconds-input::-webkit-inner-spin-button, 
        #seconds-input::-webkit-outer-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        /* Style pour l'overlay de pause */
        #pause-overlay p {
            font-size: 15vw;
            @media (min-width: 640px) {
                font-size: 8vw;
            }
        }
    </style>
</head>
<body class="bg-gray-50">

    <!-- Zone du Joueur 1 (Gauche en Desktop, Haut en Mobile) -->
    <div id="player1-zone" class="player-zone" onclick="switchPlayer(1)">
        <div id="winner-overlay-1" class="winner-overlay hidden">GAGNANT</div>
        <div id="time1" class="clock-display">
            <div id="indicator1" class="active-indicator"></div>
            <span class="time-wrapper">
                <span class="main-time">05:00</span>
                <span class="hundredths">.00</span>
            </span>
        </div>
    </div>

    <!-- Contrôles Centraux -->
    <div id="controls" class="absolute inset-0 pointer-events-none">
        
        <!-- NOUVEAU: Overlay de Pause -->
        <div id="pause-overlay" class="absolute inset-0 z-15 hidden flex items-center justify-center pointer-events-none">
            <p class="text-gray-400 font-black opacity-70 tracking-widest uppercase" 
               style="line-height: 1;">
                PAUSE
            </p>
        </div>

        <!-- Bouton Démarrer/Pause/Verrou (Haut à Gauche) -->
        <button id="main-button"
                onclick="event.stopPropagation(); handleMainButtonClick()"
                class="pointer-events-auto absolute top-4 left-4 p-4 rounded-full shadow-lg transition duration-200 z-20 hidden backdrop-blur-sm">
            <!-- Icône de Cadenas par défaut (sera mis à jour par JS) -->
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-6 h-6">
                <rect x="3" y="11" width="18" height="11" rx="2" ry="2"/>
                <path d="M7 11V7a5 5 0 0 1 10 0v4"/>
            </svg>
        </button>

        <!-- Bouton de Retour (Flèche DROITE - Mise à jour) -->
        <button id="elo-button"
                onclick="window.location.href = 'index.html';" 
                class="pointer-events-auto absolute top-4 right-4 bg-gray-300 hover:bg-gray-400 text-gray-800 p-4 rounded-full shadow-lg transition duration-200 z-20 hidden">
            <!-- Icône de flèche DROITE (Mise à jour) -->
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-6 h-6">
                <polyline points="9 18 15 12 9 6"/>
            </svg>
        </button>

        <!-- Bouton de Réglages (Engrenage) -->
        <button id="settings-button"
                onclick="event.stopPropagation(); toggleSettings(true)"
                class="pointer-events-auto absolute bottom-4 left-4 bg-gray-300 hover:bg-gray-400 text-white p-4 rounded-full shadow-lg transition duration-200 z-20 hidden">
            <!-- Icône d'engrenage SVG -->
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-6 h-6 text-gray-800">
                <circle cx="12" cy="12" r="3" />
                <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09a1.65 1.65 0 0 0 1.51-1 1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z" />
            </svg>
        </button>

        <!-- Bouton de Réinitialisation (TEXTE MAINTENANT) -->
        <button id="reset-button"
                onclick="event.stopPropagation(); resetGame()"
                class="pointer-events-auto absolute bottom-4 right-4 bg-gray-300 hover:bg-gray-400 text-gray-800 py-3 px-5 rounded-full shadow-lg transition duration-200 z-20 hidden font-bold text-xs">
            RÉINITIALISER
        </button>
    </div>

    <!-- Zone du Joueur 2 (Droite en Desktop, Bas en Mobile) -->
    <div id="player2-zone" class="player-zone" onclick="switchPlayer(2)">
        <div id="winner-overlay-2" class="winner-overlay hidden">GAGNANT</div>
        <div id="time2" class="clock-display">
            <div id="indicator2" class="active-indicator"></div>
            <span class="time-wrapper">
                <span class="main-time">05:00</span>
                <span class="hundredths">.00</span>
            </span>
        </div>
    </div>

    <!-- MODALE DE RÉGLAGES -->
    <div id="settings-modal" class="fixed inset-0 bg-black bg-opacity-70 z-30 hidden flex items-center justify-center p-4" onclick="toggleSettings(false, event)">
        <div class="bg-white rounded-xl shadow-2xl w-full max-w-sm p-6 space-y-6 md:space-y-8" onclick="event.stopPropagation()">
            <h2 class="text-2xl font-bold text-gray-800 border-b pb-2">Réglages de l'Horloge</h2>
            
            <!-- Choix du Temps Initial (Mis à jour pour Minutes:Secondes) -->
            <div class="space-y-2">
                <label for="minutes-input" class="text-lg font-semibold text-gray-700 block text-center">Temps initial (Minutes:Secondes)</label>
                <div class="flex items-center space-x-2">
                    <!-- Input Minutes -->
                    <input type="number" id="minutes-input" min="0" max="180" value="5"
                           class="w-1/2 text-center text-4xl font-extrabold p-3 border-2 border-indigo-400 rounded-lg focus:ring-indigo-500 focus:border-indigo-500 transition">
                    <span class="text-4xl font-extrabold text-gray-500">:</span>
                    <!-- Input Secondes -->
                    <input type="number" id="seconds-input" min="0" max="59" value="0"
                           class="w-1/2 text-center text-4xl font-extrabold p-3 border-2 border-indigo-400 rounded-lg focus:ring-indigo-500 focus:border-indigo-500 transition">
                </div>
            </div>

            <!-- Choix de l'Incrément -->
            <div class="space-y-3">
                <label class="text-lg font-semibold text-gray-700 block">Incrément par coup (Secondes)</label>
                
                <div class="flex flex-wrap gap-2 md:gap-4 justify-center">
                    <!-- Bouton +0 -->
                    <button data-increment="0" class="inc-btn bg-gray-200 hover:bg-gray-300 text-gray-800 font-medium py-2 px-4 rounded-full transition duration-150">
                        +0s
                    </button>
                    <!-- Bouton +2 -->
                    <button data-increment="2" class="inc-btn bg-gray-200 hover:bg-gray-300 text-gray-800 font-medium py-2 px-4 rounded-full transition duration-150">
                        +2s
                    </button>
                    <!-- Bouton +5 -->
                    <button data-increment="5" class="inc-btn bg-gray-200 hover:bg-gray-300 text-gray-800 font-medium py-2 px-4 rounded-full transition duration-150">
                        +5s
                    </button>
                    <!-- Input Personnalisé -->
                    <input type="number" id="custom-increment-input" min="0" max="60" placeholder="+ Perso"
                           class="w-24 text-center font-medium p-2 border border-gray-300 rounded-full focus:ring-indigo-500 focus:border-indigo-500 transition text-gray-800">
                </div>
                
                <p id="current-increment-display" class="text-center text-sm text-indigo-600 font-medium pt-2">
                    Incrément sélectionné : +0 secondes
                </p>
            </div>
            
            <!-- Bouton Appliquer et Fermer -->
            <button onclick="applySettings()"
                    class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-3 rounded-lg shadow-md transition duration-200 text-lg">
                Appliquer et Réinitialiser
            </button>
        </div>
    </div>

    <script>
        // --- Constantes pour localStorage ---
        const LS_INITIAL_TIME = 'chessClockInitialTime';
        const LS_INCREMENT = 'chessClockIncrement';
        const LS_STATE = 'chessClockState';

        // --- Configuration initiale ---
        // Les valeurs par défaut sont définies ici et chargées si localStorage est vide
        const DEFAULT_TIME_SECONDS = 300; 
        const DEFAULT_INCREMENT_SECONDS = 0;
        
        let initialTimeTotalSeconds = DEFAULT_TIME_SECONDS; 
        let incrementSeconds = DEFAULT_INCREMENT_SECONDS; 
        const timeLimitMs = 10; 
        const UNLOCK_DURATION = 1000; 

        // --- Variables d'état du jeu ---
        let time1 = initialTimeTotalSeconds;
        let time2 = initialTimeTotalSeconds;
        let isRunning = false; 
        let isTicking = false; 
        let isButtonLocked = true; 
        let currentPlayer = 0; 
        let winnerPlayer = 0; 
        let timerInterval;
        let lockTimeout; 

        // --- Détection de mode (CRITIQUE pour le responsive) ---
        let isDesktopMode = window.matchMedia('(min-width: 640px)').matches;
        // Flag pour savoir si l'état a été restauré (utile dans le listener de redimensionnement)
        let stateRestoredOnLoad = false; 

        // Écoute des changements de taille d'écran (pour le responsive, pas pour la restauration)
        window.matchMedia('(min-width: 640px)').addEventListener('change', (e) => {
            isDesktopMode = e.matches;
            // On ne réinitialise PAS le jeu ici, on se contente de mettre à jour les visuels.
            // La restauration sera gérée par le rechargement forcé de l'iframe si nécessaire.
            setTimeout(updateVisuals, 50); // Petit délai pour laisser le temps au CSS de se stabiliser
        });


        // --- Nouvelles définitions d'icônes SVG pour le bouton principal ---
        const ICON_LOCK = `
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-6 h-6">
                <rect x="3" y="11" width="18" height="11" rx="2" ry="2"/>
                <path d="M7 11V7a5 5 0 0 1 10 0v4"/>
            </svg>`;

        const ICON_PAUSE = `
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-6 h-6">
                <line x1="10" y1="4" x2="10" y2="20"/>
                <line x1="14" y1="4" x2="14" y2="20"/>
            </svg>`;

        const ICON_PLAY = `
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-6 h-6">
                <polygon points="5 3 19 12 5 21 5 3"/>
            </svg>`;
        
        // --- Références DOM ---
        const time1El = document.getElementById('time1');
        const time2El = document.getElementById('time2');
        const player1ZoneEl = document.getElementById('player1-zone');
        const player2ZoneEl = document.getElementById('player2-zone');
        const mainButtonEl = document.getElementById('main-button');
        const resetButtonEl = document.getElementById('reset-button');
        const settingsModalEl = document.getElementById('settings-modal');
        const settingsButtonEl = document.getElementById('settings-button');
        const eloButtonEl = document.getElementById('elo-button'); // Bouton "Retour"
        const minutesInputEl = document.getElementById('minutes-input');
        const secondsInputEl = document.getElementById('seconds-input');
        const incrementButtons = document.querySelectorAll('.inc-btn');
        const customIncrementInput = document.getElementById('custom-increment-input');
        const currentIncrementDisplay = document.getElementById('current-increment-display');
        const winnerOverlay1El = document.getElementById('winner-overlay-1');
        const winnerOverlay2El = document.getElementById('winner-overlay-2');
        const pauseOverlayEl = document.getElementById('pause-overlay');
        
        // --- Logique de Persistance (localStorage) ---
        
        // Sauvegarde l'état actuel du jeu dans localStorage
        function saveGameState() {
            try {
                const state = {
                    time1: time1,
                    time2: time2,
                    isRunning: isRunning,
                    isTicking: isTicking,
                    currentPlayer: currentPlayer,
                    winnerPlayer: winnerPlayer,
                    initialTimeTotalSeconds: initialTimeTotalSeconds,
                    incrementSeconds: incrementSeconds
                };
                localStorage.setItem(LS_STATE, JSON.stringify(state));
                console.log("[LS] État du jeu sauvegardé.");
            } catch (error) {
                console.error("Erreur lors de la sauvegarde de l'état du jeu:", error);
            }
        }
        
        // Charge l'état du jeu depuis localStorage
        function loadGameState() {
            // 1. Charger les réglages de temps
            try {
                const storedTime = localStorage.getItem(LS_INITIAL_TIME);
                if (storedTime) {
                    initialTimeTotalSeconds = parseFloat(storedTime);
                }
                const storedIncrement = localStorage.getItem(LS_INCREMENT);
                if (storedIncrement) {
                    incrementSeconds = parseInt(storedIncrement);
                }
            } catch (error) {
                 console.error("Erreur lors du chargement des réglages:", error);
            }

            // 2. Charger l'état de la partie si elle était en cours
            try {
                const storedState = localStorage.getItem(LS_STATE);
                if (storedState) {
                    const state = JSON.parse(storedState);

                    // Vérifie si l'état sauvegardé est une partie non terminée
                    if (state.isRunning || state.isTicking || state.winnerPlayer === 0 && (state.time1 < state.initialTimeTotalSeconds || state.time2 < state.initialTimeTotalSeconds)) { 
                        time1 = state.time1;
                        time2 = state.time2;
                        isRunning = state.isRunning;
                        isTicking = state.isTicking;
                        currentPlayer = state.currentPlayer;
                        winnerPlayer = state.winnerPlayer;
                        
                        // Mise à jour des réglages persistants si l'état est valide
                        initialTimeTotalSeconds = state.initialTimeTotalSeconds;
                        incrementSeconds = state.incrementSeconds;
                        
                        console.log("[LS] État du jeu restauré.");
                        
                        return true; // État restauré avec succès
                    }
                }
            } catch (error) {
                console.error("Erreur lors de la restauration de l'état du jeu:", error);
            }
            return false;
        }

        // Sauvegarde des réglages indépendamment de l'état du jeu
        function saveSettings() {
             try {
                localStorage.setItem(LS_INITIAL_TIME, initialTimeTotalSeconds.toString());
                localStorage.setItem(LS_INCREMENT, incrementSeconds.toString());
                console.log("[LS] Réglages sauvegardés.");
             } catch (error) {
                console.error("Erreur lors de la sauvegarde des réglages:", error);
             }
        }
        
        // --- Fonctions Utilitaires ---

        function formatTime(totalSeconds) {
            if (totalSeconds < 0) totalSeconds = 0;
            // Utilise Math.round pour minimiser l'erreur d'arrondi
            const totalMs = Math.max(0, Math.round(totalSeconds * 1000)); 
            const minutes = Math.floor(totalMs / 60000);
            const seconds = Math.floor((totalMs % 60000) / 1000);
            const hundredths = Math.floor((totalMs % 1000) / 10); 
            const mmss = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
            const cs = `${String(hundredths).padStart(2, '0')}`; 
            return { mmss, cs };
        }
        
        // Active le déverrouillage temporaire du bouton (Mobile uniquement)
        function unlockButton() {
            if (isDesktopMode) return; // Ignorer en mode Desktop

            if (lockTimeout) {
                clearTimeout(lockTimeout); 
            }

            isButtonLocked = false;
            updateVisuals(); 

            console.log("[Verrou] Bouton déverrouillé pour 1 seconde.");

            lockTimeout = setTimeout(() => {
                if (isRunning && winnerPlayer === 0 && !isTicking) { 
                    isButtonLocked = true;
                    updateVisuals();
                    console.log("[Verrou] Reverrouillage automatique.");
                } else {
                    console.log("[Verrou] Reverrouillage annulé (jeu arrêté ou en cours).");
                }
            }, UNLOCK_DURATION);
        }

        // Gère les actions sur le bouton principal (Cadenas -> Pause/Reprendre)
        function handleMainButtonClick() {
            if (!isRunning || winnerPlayer !== 0) {
                console.log("[MainButton] Bouton Ignoré: Le jeu n'est pas en cours.");
                return;
            }

            if (isDesktopMode) {
                // DESKTOP : Le bouton est toujours un simple toggle Pause/Play.
                startStop();
            } else {
                // MOBILE : Logique de verrouillage
                if (isButtonLocked) {
                    unlockButton(); 
                } else {
                    startStop(); 
                    // Après avoir cliqué sur Pause/Reprendre, on reverrouille immédiatement
                    if (isRunning) { 
                        isButtonLocked = true;
                        clearTimeout(lockTimeout); 
                        updateVisuals(); 
                        console.log("[Verrou] Verrouillage immédiat après action Pause/Reprendre.");
                    }
                }
            }
            saveGameState(); // Sauvegarde l'état après un changement (pause/reprise)
        }


        // --- Logique de l'Horloge ---

        function updateDisplay(player) {
            const time = player === 1 ? time1 : time2;
            const element = player === 1 ? time1El : time2El;
            const zone = player === 1 ? player1ZoneEl : player2ZoneEl;
            const winnerOverlayEl = player === 1 ? winnerOverlay1El : winnerOverlay2El;

            const { mmss, cs } = formatTime(time);

            // Mise à jour de l'affichage du temps (maintenant dans une structure pour conserver l'indicateur)
            const indicatorEl = document.getElementById(`indicator${player}`);
            if (indicatorEl) {
                // On met à jour seulement le temps (les spans main-time et hundredths sont les enfants)
                const timeSpans = element.querySelector('.time-wrapper');
                if (timeSpans) {
                     timeSpans.innerHTML = `
                        <span class="main-time">${mmss}</span>
                        <span class="hundredths">.${cs}</span>
                    `;
                }
            } 

            const baseColor1 = '#1e293b'; 
            const baseColor2 = '#f1f5f9'; 
            const alertColor = '#ef4444'; 
            
            // Détermine si le temps défile pour ce joueur (uniquement si le temps défile)
            const isTappable = currentPlayer === player && isTicking;

            // Détermine si le joueur est le joueur actuel (même en pause)
            const isActivePlayer = currentPlayer === player && isRunning; 

            if (isTicking) {
                zone.classList.add('shadow-2xl'); 
                zone.style.cursor = 'pointer';
            } else {
                zone.classList.remove('shadow-2xl');
                // Laisse le curseur par défaut quand en pause ou pas son tour
                zone.style.cursor = 'default'; 
            }

            // Changement de couleur pour le temps bas (seulement quand le temps défile)
            const isLowTime = isTappable && time < 10 && time > 0;
            
            zone.style.backgroundColor = isLowTime 
                ? alertColor
                : (player === 1 ? baseColor1 : baseColor2);
            
            if (player === 2) {
                const textColor = isLowTime ? 'white' : baseColor1;
                if (zone) zone.style.color = textColor;
                winnerOverlay2El.style.color = baseColor1; 
            } else {
                 if (zone) zone.style.color = 'white';
                 winnerOverlay1El.style.color = 'white'; 
            }

            // Gestion de l'affichage GAGNANT/PERDANT
            if (winnerPlayer === 1 && player === 2) {
                winnerOverlayEl.textContent = 'PERDANT';
                winnerOverlayEl.classList.remove('hidden');
            } else if (winnerPlayer === 2 && player === 1) {
                winnerOverlayEl.textContent = 'PERDANT';
                winnerOverlayEl.classList.remove('hidden');
            } else if (winnerPlayer === player) {
                 winnerOverlayEl.textContent = 'GAGNANT';
                 winnerOverlayEl.classList.remove('hidden');
            } else {
                winnerOverlayEl.classList.add('hidden');
            }

            // PASTILLE VISIBLE MÊME EN PAUSE
            const currentIndicatorEl = document.getElementById(`indicator${player}`);
            if (currentIndicatorEl) {
                currentIndicatorEl.classList.remove('active-p1-white', 'active-p2-dark');
                
                // Condition pour afficher la pastille: Le jeu est en cours ET c'est le tour de ce joueur.
                if (isActivePlayer) {
                    currentIndicatorEl.classList.add(player === 1 ? 'active-p1-white' : 'active-p2-dark');
                }
                // Si c'est en pause, on enlève l'ombre de la zone active pour indiquer l'état "dormant"
                if (isActivePlayer && !isTicking) {
                   zone.classList.remove('shadow-2xl'); 
                }
            }
        }

        function tick() {
            if (!isTicking) return;
            const timeDecrement = timeLimitMs / 1000;

            if (currentPlayer === 1) {
                time1 -= timeDecrement;
                if (time1 <= 0) {
                    time1 = 0;
                    gameOver(1);
                }
            } else if (currentPlayer === 2) {
                time2 -= timeDecrement;
                if (time2 <= 0) {
                    time2 = 0;
                    gameOver(2);
                }
            }

            updateDisplay(1);
            updateDisplay(2);
            // Sauvegarde à chaque tick pour assurer la persistance de l'état précis
            saveGameState(); 
        }

        function switchPlayer(clickedPlayer) {
            const isGameOver = winnerPlayer !== 0; 
            if (isGameOver) return;

            // LOGIQUE DE DÉMARRAGE 
            if (!isRunning) {
                isRunning = true; 
                isTicking = true; 
                
                // Le joueur qui clique cède le tour à l'autre joueur.
                currentPlayer = clickedPlayer === 1 ? 2 : 1; 

                timerInterval = setInterval(tick, timeLimitMs);
                console.log(`[Switch] Démarrage initial par P${clickedPlayer}. Horloge P${currentPlayer} démarrée.`);
            }
            // Logique de COUP NORMAL : Horloge en cours de décompte
            else if (isTicking) {
                if (clickedPlayer === currentPlayer) {
                    
                    if (currentPlayer === 1) {
                        time1 += incrementSeconds;
                        currentPlayer = 2; 
                        console.log(`[Switch] P1 joue. Nouveau Joueur: P${currentPlayer}.`);
                    } else { // currentPlayer === 2
                        time2 += incrementSeconds;
                        currentPlayer = 1; 
                        console.log(`[Switch] P2 joue. Nouveau Joueur: P${currentPlayer}.`);
                    }
                } else {
                    console.log(`[Switch] Rejet: Clic sur P${clickedPlayer}, mais P${currentPlayer} est actif.`);
                    return;
                }
            }
            // Si en pause, on ignore le clic sur la zone
            else if (isRunning && !isTicking) {
                 console.log("[Switch] Rejet: Horloge en pause, veuillez utiliser le bouton 'Reprendre'.");
                 return;
            }
            
            // Verrouillage du bouton principal après un coup (Mobile seulement)
            if (!isDesktopMode) {
                isButtonLocked = true;
                clearTimeout(lockTimeout); 
            }
            
            updateVisuals();
            saveGameState(); // Sauvegarde après un coup
        }
        
        function handleSpacebarPress() {
            if (settingsModalEl && !settingsModalEl.classList.contains('hidden')) {
                return; 
            }
            
            if (isTicking) {
                switchPlayer(currentPlayer);
            } 
            else if (isRunning && !isTicking && time1 > 0 && time2 > 0) {
                // Si la partie est en pause (isRunning=true, isTicking=false)
                if (isDesktopMode) {
                    // Desktop: La barre d'espace agit comme le bouton Pause/Play (startStop)
                    startStop(); 
                } else {
                    // Mobile: La barre d'espace agit comme un clic sur le bouton central
                    if (isButtonLocked) {
                        unlockButton();
                    } else {
                        startStop();
                    }
                }
            }
        }

        // Démarre/met en pause la partie
        function startStop() {
            if (!isRunning || winnerPlayer !== 0) {
                return;
            }
            
            if (!isDesktopMode && isButtonLocked) {
                return; // En mobile, nécessite un déverrouillage préalable
            }

            if (isTicking) {
                clearInterval(timerInterval);
                isTicking = false;
                console.log(`[StartStop] Pause. Joueur en attente: ${currentPlayer}`);
            } 
            else {
                isTicking = true;
                timerInterval = setInterval(tick, timeLimitMs);
                console.log(`[StartStop] Reprise de la partie. Joueur actif: ${currentPlayer}`);
            }

            updateVisuals();
            saveGameState(); // Sauvegarde après une pause/reprise
        }

        function gameOver(loser) {
            isRunning = false;
            isTicking = false;
            clearInterval(timerInterval);
            currentPlayer = 0;
            winnerPlayer = loser === 1 ? 2 : 1; 
            
            clearTimeout(lockTimeout); 
            isButtonLocked = true; 

            updateDisplay(1);
            updateDisplay(2);
            updateVisuals();
            localStorage.removeItem(LS_STATE); // Supprime l'état après la fin de la partie
        }

        function resetGame() {
            clearInterval(timerInterval);
            clearTimeout(lockTimeout);
            time1 = initialTimeTotalSeconds;
            time2 = initialTimeTotalSeconds;
            isRunning = false; 
            isTicking = false; 
            isButtonLocked = true; 
            currentPlayer = 0;
            winnerPlayer = 0; 
            console.log("[Reset] Jeu réinitialisé.");
            
            localStorage.removeItem(LS_STATE); // S'assurer que tout état précédent est effacé

            updateVisuals();
        }

        // Met à jour tous les éléments visuels, y compris le bouton principal
        function updateVisuals() {
            updateDisplay(1);
            updateDisplay(2);
            
            const isGameOver = winnerPlayer !== 0;
            
            // 1. Visibilité du bouton principal : Seulement si la partie est initialisée et non terminée
            mainButtonEl.classList.toggle('hidden', !isRunning || isGameOver);


            // 2. Gère le contenu et l'état de clic du bouton principal
            let iconHTML;
            let buttonBaseClasses;
            
            // Classes de couleurs et de fonds à retirer systématiquement
            const classesToRemove = [
                'bg-white/30', 'border', 'border-gray-400', 'hover:bg-white/50', 'text-gray-800',
                'bg-red-600', 'hover:bg-red-700', 'bg-green-600', 'hover:bg-green-700', 'text-white'
            ];
            classesToRemove.forEach(cls => mainButtonEl.classList.remove(cls));
            
            mainButtonEl.classList.add('backdrop-blur-sm'); // Laisse le flou en permanence

            if (isDesktopMode) {
                // *** MODE DESKTOP ***
                if (isTicking) {
                    iconHTML = ICON_PAUSE;
                } else { 
                    iconHTML = ICON_PLAY;
                }
                buttonBaseClasses = 'bg-white/30 border border-gray-400 text-gray-800 hover:bg-white/50';
                
            } else {
                // *** MODE MOBILE (Logique Cadenas) ***
                if (isButtonLocked) {
                    iconHTML = ICON_LOCK;
                    buttonBaseClasses = 'bg-white/30 border border-gray-400 text-gray-800 hover:bg-white/50'; 
                } else if (isTicking) {
                    iconHTML = ICON_PAUSE;
                    buttonBaseClasses = 'bg-red-600 hover:bg-red-700 text-white';
                } else if (isRunning && !isTicking) {
                    iconHTML = ICON_PLAY;
                    buttonBaseClasses = 'bg-green-600 hover:bg-green-700 text-white';
                }
            }
            
            mainButtonEl.innerHTML = iconHTML; // Met à jour l'icône
            buttonBaseClasses.split(' ').forEach(cls => mainButtonEl.classList.add(cls));

            mainButtonEl.disabled = false;
            mainButtonEl.style.cursor = 'pointer';

            // 3. Contrôle de la visibilité des autres boutons de contrôle
            // Les boutons sont visibles SI :
            // a) Le jeu n'a pas encore démarré (isRunning = false)
            // b) Le jeu est terminé (winnerPlayer != 0)
            // c) Le jeu est en pause (isRunning = true ET isTicking = false)
            
            const isControlVisible = !isRunning || isGameOver || (isRunning && !isTicking); 
            
            settingsButtonEl.classList.toggle('hidden', !isControlVisible);
            resetButtonEl.classList.toggle('hidden', !isControlVisible);
            eloButtonEl.classList.toggle('hidden', !isControlVisible); // Bouton Retour/ELO
            
            // NOUVEAU: Affichage de l'overlay de pause
            const isPaused = isRunning && !isTicking && winnerPlayer === 0;
            if (pauseOverlayEl) {
                pauseOverlayEl.classList.toggle('hidden', !isPaused);
            }
        }

        // --- Logique des Réglages (Mode Édition) ---

        function toggleSettings(show, event) {
            // Permet l'ouverture des réglages même en pause, mais pas quand le temps défile
            if (isTicking) return; 
            
            if (show) {
                const minutes = Math.floor(initialTimeTotalSeconds / 60);
                const seconds = Math.floor(initialTimeTotalSeconds % 60);

                minutesInputEl.value = minutes;
                secondsInputEl.value = seconds;
                
                customIncrementInput.value = incrementSeconds;
                updateIncrementSelection(incrementSeconds);
                settingsModalEl.classList.remove('hidden');
            } else if (!event || event.target === settingsModalEl) {
                settingsModalEl.classList.add('hidden');
            }
        }

        function updateIncrementSelection(selectedIncrement) {
            incrementButtons.forEach(btn => {
                const inc = parseInt(btn.dataset.increment);
                if (inc === selectedIncrement) {
                    btn.classList.add('bg-indigo-600', 'text-white');
                    btn.classList.remove('bg-gray-200', 'text-gray-800');
                } else {
                    btn.classList.remove('bg-indigo-600', 'text-white');
                    btn.classList.add('bg-gray-200', 'text-gray-800');
                }
            });

            customIncrementInput.classList.remove('bg-indigo-600', 'text-white', 'font-bold');
            if (![0, 2, 5].includes(selectedIncrement)) {
                customIncrementInput.classList.add('bg-indigo-600', 'text-white', 'font-bold');
            }

            currentIncrementDisplay.textContent = `Incrément sélectionné : +${selectedIncrement} secondes`;
        }

        incrementButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                const inc = parseInt(btn.dataset.increment);
                incrementSeconds = inc; 
                customIncrementInput.value = ''; 
                updateIncrementSelection(inc);
            });
        });

        customIncrementInput.addEventListener('input', () => {
            let inc = parseInt(customIncrementInput.value);
            if (isNaN(inc) || inc < 0) inc = 0;
            if (inc > 60) inc = 60; 
            customIncrementInput.value = inc;

            incrementSeconds = inc;
            updateIncrementSelection(inc);
        });

        function applySettings() {
            let newMinutes = parseInt(minutesInputEl.value) || 0;
            let newSeconds = parseInt(secondsInputEl.value) || 0;
            let newIncrementSeconds = parseInt(incrementSeconds);

            if (isNaN(newMinutes) || newMinutes < 0) newMinutes = 0;
            if (newMinutes > 180) newMinutes = 180;
            if (isNaN(newSeconds) || newSeconds < 0) newSeconds = 0;
            if (newSeconds > 59) newSeconds = 59;
            
            const newTotalSeconds = (newMinutes * 60) + newSeconds;
            
            if (newTotalSeconds === 0) {
                 initialTimeTotalSeconds = 60; 
            } else {
                 initialTimeTotalSeconds = newTotalSeconds;
            }

            if (isNaN(newIncrementSeconds) || newIncrementSeconds < 0) newIncrementSeconds = 0;

            incrementSeconds = newIncrementSeconds;
            
            if (newTotalSeconds === 0) {
                 minutesInputEl.value = 1;
                 secondsInputEl.value = 0;
            }

            console.log(`[Settings] Temps initial: ${Math.floor(initialTimeTotalSeconds / 60)}:${String(initialTimeTotalSeconds % 60).padStart(2, '0')} (Incrément: ${incrementSeconds} s)`);

            saveSettings(); // Sauvegarde les nouveaux réglages
            toggleSettings(false); 
            resetGame(); 
        }
        
        // --- Gestionnaire d'Événements Clavier ---
        document.addEventListener('keydown', (event) => {
            if (event.key === ' ' || event.keyCode === 32) {
                event.preventDefault(); 
                
                if (settingsModalEl && !settingsModalEl.classList.contains('hidden')) {
                    return;
                }
                
                handleSpacebarPress();
            }
        });


        // Initialisation au chargement
        // CRITIQUE : Démarre la fonction de restauration au plus tôt possible.
        (function initialize() {
            // 1. Tente de restaurer l'état
            stateRestoredOnLoad = loadGameState();
            
            // 2. Si non restauré (nouvelle partie ou partie terminée), on initialise avec les réglages chargés
            if (!stateRestoredOnLoad) {
                time1 = initialTimeTotalSeconds;
                time2 = initialTimeTotalSeconds;
            }
            
            // 3. Si le jeu était en cours au moment du rechargement, on redémarre l'intervalle
            if (isTicking) {
                 clearInterval(timerInterval);
                 timerInterval = setInterval(tick, timeLimitMs);
                 console.log("[Restore] Redémarrage du timer après restauration.");
            }

            // 4. Met à jour l'affichage initial
            updateVisuals(); 
            
            // 5. Nettoie l'état sauvegardé si la restauration a réussi et que le jeu n'est pas terminé.
            // On ne veut le nettoyer qu'APRÈS avoir redémarré le timer.
            if (stateRestoredOnLoad && winnerPlayer === 0) {
                localStorage.removeItem(LS_STATE);
                console.log("[LS] État temporaire effacé après restauration réussie.");
            }
        })();

    </script>
</body>
</html>
